<?xml version="1.0" encoding="UTF-8"?>
<operation>
  <input globalname="Bounding box">
    <CRS>EPSG:4326</CRS>
    <minx>152.19999999999999</minx>
    <miny>-31.399999999999999</miny>
    <maxx>153.19999999999999</maxx>
    <maxy>-30.399999999999999</maxy>
    <resx>0</resx>
    <resy>0</resy>
  </input>
  <input globalname="Bounding box toggle">1</input>
  <input globalname="Bounding box buffer">0.5</input>
  <input globalname="Bounding box auto toggle">0</input>
  <input globalname="Curing/Layer default">50</input>
  <input globalname="Curing/Layer projection WKT"></input>
  <input globalname="Curing/Layer source file"></input>
  <input globalname="Curing/Layer interpolation">1</input>
  <input globalname="Elevation/Layer default">0</input>
  <input globalname="Elevation/Layer projection WKT">EPSG:28356</input>
  <input globalname="Elevation/Layer source file">./Input/LNC_DEM_MGA94_56/LNC_DEM_MGA94_56.tif</input>
  <input globalname="Elevation/Layer interpolation">1</input>
  <input globalname="Fire history/Layer default">2</input>
  <input globalname="Fire history/Layer projection WKT"></input>
  <input globalname="Fire history/Layer source file"></input>
  <input globalname="Fire history/Layer interpolation">1</input>
  <input globalname="Fuel load/Layer default">0</input>
  <input globalname="Fuel load/Layer projection WKT"></input>
  <input globalname="Fuel load/Layer source file"></input>
  <input globalname="Fuel load/Layer interpolation">1</input>
  <input globalname="Classification/Layer projection WKT">EPSG:4326</input>
  <input globalname="Classification/Layer source file">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Input/LNC_Vegetation_gda94_latlon/LNC_vegetation_GDA94_latlon.tif</input>
  <input globalname="Classification/Shape mask projection WKT"></input>
  <input globalname="Classification/Shape mask source file"></input>
  <input globalname="Classification/Shape mask GeoJSON"></input>
  <input globalname="Classification/Shape mask state name"></input>
  <input globalname="Gridded/Source directory"></input>
  <input globalname="Gridded/Layer projection WKT"></input>
  <input globalname="Gridded/Start time overwrite"></input>
  <input globalname="Gridded/Time conversion coefficient">0</input>
  <input globalname="Gridded/Wind/Layer direction source file"></input>
  <input globalname="Gridded/Wind/Layer direction source filter"></input>
  <input globalname="Gridded/Wind/Layer direction scale">0</input>
  <input globalname="Gridded/Wind/Layer direction offset">0</input>
  <input globalname="Gridded/Wind/Use direction speed">1</input>
  <input globalname="Gridded/Wind/Layer magnitude source file"></input>
  <input globalname="Gridded/Wind/Layer magnitude source filter"></input>
  <input globalname="Gridded/Wind/Layer magnitude scale">0</input>
  <input globalname="Gridded/Wind/Layer magnitude offset">0</input>
  <input globalname="Gridded/Relative humidity/Layer source file"></input>
  <input globalname="Gridded/Relative humidity/Layer source filter"></input>
  <input globalname="Gridded/Relative humidity/Layer scale">0</input>
  <input globalname="Gridded/Relative humidity/Layer offset">0</input>
  <input globalname="Gridded/Temperature/Layer source file"></input>
  <input globalname="Gridded/Temperature/Layer source filter"></input>
  <input globalname="Gridded/Temperature/Layer scale">0</input>
  <input globalname="Gridded/Temperature/Layer offset">0</input>
  <input globalname="Gridded/Dew point temperature/Layer source file"></input>
  <input globalname="Gridded/Dew point temperature/Layer source filter"></input>
  <input globalname="Gridded/Dew point temperature/Layer scale">0</input>
  <input globalname="Gridded/Dew point temperature/Layer offset">0</input>
  <input globalname="Gridded/Drought factor/Layer source file"></input>
  <input globalname="Gridded/Drought factor/Layer source filter"></input>
  <input globalname="Gridded/Drought factor/Layer scale">0</input>
  <input globalname="Gridded/Drought factor/Layer offset">0</input>
  <input globalname="Custom/Layer name 1">fhs_surface</input>
  <input globalname="Custom/Layer name 2">fhs_near_surface</input>
  <input globalname="Custom/Layer name 3">h_near_surface</input>
  <input globalname="Custom/Layer name 4">fuel_height</input>
  <input globalname="Custom/Layer name 5"></input>
  <input globalname="Custom/Layer name 6"></input>
  <input globalname="Custom/Layer name 7"></input>
  <input globalname="Custom/Layer name 8"></input>
  <input globalname="Custom/Layer name 9"></input>
  <input globalname="Custom/Layer name 10"></input>
  <input globalname="Custom/Layer name 11"></input>
  <input globalname="Custom/Layer name 12"></input>
  <input globalname="Custom/Layer name 13"></input>
  <input globalname="Custom/Layer name 14"></input>
  <input globalname="Custom/Layer name 15"></input>
  <input globalname="Custom/Layer name 16"></input>
  <input globalname="Custom/Layer name 17"></input>
  <input globalname="Custom/Layer name 18"></input>
  <input globalname="Custom/Layer name 19"></input>
  <input globalname="Custom/Layer name 20"></input>
  <input globalname="Custom/Layer default 1">0</input>
  <input globalname="Custom/Layer default 2">0</input>
  <input globalname="Custom/Layer default 3">0</input>
  <input globalname="Custom/Layer default 4">1.5</input>
  <input globalname="Custom/Layer default 5">0</input>
  <input globalname="Custom/Layer default 6">0</input>
  <input globalname="Custom/Layer default 7">0</input>
  <input globalname="Custom/Layer default 8">0</input>
  <input globalname="Custom/Layer default 9">0</input>
  <input globalname="Custom/Layer default 10">0</input>
  <input globalname="Custom/Layer default 11">0</input>
  <input globalname="Custom/Layer default 12">0</input>
  <input globalname="Custom/Layer default 13">0</input>
  <input globalname="Custom/Layer default 14">0</input>
  <input globalname="Custom/Layer default 15">0</input>
  <input globalname="Custom/Layer default 16">0</input>
  <input globalname="Custom/Layer default 17">0</input>
  <input globalname="Custom/Layer default 18">0</input>
  <input globalname="Custom/Layer default 19">0</input>
  <input globalname="Custom/Layer default 20">0</input>
  <input globalname="Custom/Layer file name 1"></input>
  <input globalname="Custom/Layer file name 2"></input>
  <input globalname="Custom/Layer file name 3"></input>
  <input globalname="Custom/Layer file name 4"></input>
  <input globalname="Custom/Layer file name 5"></input>
  <input globalname="Custom/Layer file name 6"></input>
  <input globalname="Custom/Layer file name 7"></input>
  <input globalname="Custom/Layer file name 8"></input>
  <input globalname="Custom/Layer file name 9"></input>
  <input globalname="Custom/Layer file name 10"></input>
  <input globalname="Custom/Layer file name 11"></input>
  <input globalname="Custom/Layer file name 12"></input>
  <input globalname="Custom/Layer file name 13"></input>
  <input globalname="Custom/Layer file name 14"></input>
  <input globalname="Custom/Layer file name 15"></input>
  <input globalname="Custom/Layer file name 16"></input>
  <input globalname="Custom/Layer file name 17"></input>
  <input globalname="Custom/Layer file name 18"></input>
  <input globalname="Custom/Layer file name 19"></input>
  <input globalname="Custom/Layer file name 20"></input>
  <input globalname="Custom/Layer projection 1"></input>
  <input globalname="Custom/Layer projection 2"></input>
  <input globalname="Custom/Layer projection 3"></input>
  <input globalname="Custom/Layer projection 4"></input>
  <input globalname="Custom/Layer projection 5"></input>
  <input globalname="Custom/Layer projection 6"></input>
  <input globalname="Custom/Layer projection 7"></input>
  <input globalname="Custom/Layer projection 8"></input>
  <input globalname="Custom/Layer projection 9"></input>
  <input globalname="Custom/Layer projection 10"></input>
  <input globalname="Custom/Layer projection 11"></input>
  <input globalname="Custom/Layer projection 12"></input>
  <input globalname="Custom/Layer projection 13"></input>
  <input globalname="Custom/Layer projection 14"></input>
  <input globalname="Custom/Layer projection 15"></input>
  <input globalname="Custom/Layer projection 16"></input>
  <input globalname="Custom/Layer projection 17"></input>
  <input globalname="Custom/Layer projection 18"></input>
  <input globalname="Custom/Layer projection 19"></input>
  <input globalname="Custom/Layer projection 20"></input>
  <input globalname="Custom/Layer interpolation 1">0</input>
  <input globalname="Custom/Layer interpolation 2">0</input>
  <input globalname="Custom/Layer interpolation 3">0</input>
  <input globalname="Custom/Layer interpolation 4">0</input>
  <input globalname="Custom/Layer interpolation 5">0</input>
  <input globalname="Custom/Layer interpolation 6">0</input>
  <input globalname="Custom/Layer interpolation 7">0</input>
  <input globalname="Custom/Layer interpolation 8">0</input>
  <input globalname="Custom/Layer interpolation 9">0</input>
  <input globalname="Custom/Layer interpolation 10">0</input>
  <input globalname="Custom/Layer interpolation 11">0</input>
  <input globalname="Custom/Layer interpolation 12">0</input>
  <input globalname="Custom/Layer interpolation 13">0</input>
  <input globalname="Custom/Layer interpolation 14">0</input>
  <input globalname="Custom/Layer interpolation 15">0</input>
  <input globalname="Custom/Layer interpolation 16">0</input>
  <input globalname="Custom/Layer interpolation 17">0</input>
  <input globalname="Custom/Layer interpolation 18">0</input>
  <input globalname="Custom/Layer interpolation 19">0</input>
  <input globalname="Custom/Layer interpolation 20">0</input>
  <input globalname="Series/Script">&quot;&quot;&quot;bom_point_forecasts - reads a time series of weather data from a BOM Point Forecast csv file.

Inputs from Spark:
fileName      pathname of the input csv file
timeZone      UTC offset eg. +11:00

Variables read from csv file - order of columns:
date          Local Date 'DD Mmm YYY'
time          Local Time 'HH:MM'
temp          Air temperature 'Temp (C)'
rel_hum       Relative humidity 'RH (%)'.
wind_speed    Wind speed 'Wind Speed (km/h)'.
wind_dir      Wind bearing in degrees 'Wind Dir'.
drought_fac   'Drought factor' (1-10).
ffdi          Forest Fire Danger Index 'FFDI'
gfdi          Grass Fire Danger Index 'GFDI'.


If debugging outside of Spark must set input varriables

&quot;&quot;&quot;
import csv
import datetime as dt

months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']


DEBUG = False  #set to True if debugging outside of Spark

# set input variables if debugging outside of Spark
if DEBUG:
    fileName = &quot;./Input/weather_series/2020-08-21-08-08-07_PointForecast.csv&quot;
    timeZone = &quot;+10:00&quot;
    time = []
    wind_speed = []
    wind_dir = []
    temp = []
    rel_hum = []
    dew_temp = []
    drought_fac = []





with open(fileName) as f:
    weather = csv.reader(f)
    header = True
    series_array = [temp, rel_hum, wind_dir, wind_speed, drought_fac]
    
    for row in weather:
        try:
            d = row[0].split(' ')
            date = dt.date(int(d[2]), int(months.index(d[1])+1), int(d[0]))
            weather_data = row[2:]
            time.append(f'{date.isoformat()}T{row[1]}:00{timeZone}')
            for i in range(len(series_array)):
                series_array[i].append(weather_data[i])


        except IndexError: # not a date of type &quot;DD Mmm YYYY&quot;            
            if DEBUG: print('not a date')
        
            # populate series


if DEBUG:
    for t in range(len(time)):
        print(time[t], end='\t')
        for r in range(len(series_array)):
            try:
                print(f&quot;{series_array[r][t]}&quot;, end=&quot;\t&quot;)
            except IndexError:
                print(&quot;&quot;, end=&quot;\t&quot;)
        print('')</input>
  <input globalname="Series/Source file">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Input/weather_series/2020-08-25-20-12-15_PointForecast.csv</input>
  <input globalname="Series/Time zone">+10:00</input>
  <input globalname="Series/Wind speed stdev">0</input>
  <input globalname="Series/Wind bearing stdev">0</input>
  <input globalname="Initialisation Python input file">./Input/vegetation_lookup/lnc_vegetation_2.csv</input>
  <input globalname="Initialisation Python input file 2">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Scripts/initStr_starter.c</input>
  <input globalname="Initialisation Python script">''' Define the display labels of the output raster layers.
'''

import json

# Write to JSON
JSON = {
    &quot;Layers&quot;: [
        {
            &quot;Name&quot;: &quot;Arrival time (s)&quot;
        },
        {
            &quot;Name&quot;: &quot;Speed (m/s)&quot;
        },
        {
            &quot;Name&quot;: &quot;Maximum intensity (kW/m)&quot;
        },
        {
            &quot;Name&quot;: &quot;Maximum flame height (m)&quot;
        },
        {
            &quot;Name&quot;: &quot;Class&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Wind x-velocity&quot;
        },
        {
            &quot;Name&quot;: &quot;Wind y-velocity&quot;
        }
    ]
}
outputJSON = json.dumps(JSON)


''' land_to_fuel reclass - reclassify a land class raster to a fuel class.

Uses a csv lookup table to reclassify a land class into a fuel class
Generates an OpenCL C script and appends that to the initString variable of the 
Spark framework so that it executes between the start init code and the end init code.

Inputs:
fileName - the filename of the *.csv lookup table
'''

DEBUG = True  #set True if running this script outside of the Spark framework

import csv

#-----------------------------------------------------------------
# a bit of set up stuff

lc_header = 'Land class'
lc_description = 'Description'
fc_header = 'Fuel class'

spread_models = ['unburnable', 
                'fc_grassland',
                'fc_woodland',
                'fc_sclerophyll_dry',
                'fc_sclerophyll_wet',
                'fc_rainforest',
                'fc_other_forest',
                'fc_heath_coastal',
                'fc_heath_semi_arid',
                'fc_pine',
                'fc_moorlands',
                'fc_wetlands',
                'fc_urban']

if DEBUG:
    fileName = './Input/vegetation_lookup/lnc_vegetation_2.csv'
    fileName2 = './Scripts/initStr_starter.c'
    initString = &quot;&quot;


#------------------------------------------------------------------
# Define fuel classes and land classes as objects

class FuelClass(object):
    ''' Fuel type class.

    Used to store attributes of the fuel class including a list
    of the land classes it is comprised of. The land classes should correspond to the
    'land classification' raster layer in the Spark framework.

    Attributes:
        _fuel_class: an integer between 1 and 12 corresponding to a Spark spread model.
        _land_classes[]: a list of the land classes comprising the fuel class.
        _name: a string naming the class, default value &quot;&quot;
        _description: a string giving a short deacription of the class, default value &quot;&quot;

    '''

    def __init__(self, fuel_class: int):
        '''Inits FuelClass with a class corrspondinig to the Spark spread models.
        
        The value of fuel_class should be between 1 and 12.
        '''
        self._fuel_class = fuel_class
        self._land_classes = []
        self._name = &quot;&quot;
        self._description = &quot;&quot;

    def add_land_class(self, land_class):
        '''adds a land class to the list of land classes that comprise this fuel class.'''
        self._land_classes.append(land_class)

    def set_name(self, name: str):
        '''Sets the name of the fuel class.'''
        self._name = name

    def set_description(self, description: str):
        '''Sets the description of the fuel class.'''
        self._description = description

    def get_class(self) -&gt; int:
        '''Gets the name of the fuel class.'''
        return self._fuel_class

    def get_name(self) -&gt; str:
        '''Gets the name of the fuel class.'''
        return self._name

    def get_description(self) -&gt; str:
        '''Gets the description of the fuel class.'''
        return self._description

    def get_land_classes(self):
        return self._land_classes

class LandClass(object):
    ''' Land type class.

    Used to hold attributes of a land classes.

    Attributes:
        _land_class: an integer corresponding to the Spark land classification raster and the lookup csv
        _name: a string naming the class, default value &quot;&quot;
        _description: a string giving a short deacription of the class, default value &quot;&quot;
        _fuel_class: int indicating the fuelclass to which it belongs
    '''

    def __init__(self, land_class: int):
        '''Inits LandClass with a class corrsponding to a column in the lookup csv
        '''

        self._land_class = land_class
        self._name = &quot;&quot;
        self._description = &quot;&quot;

    def set_name(self, name: str):
        '''Sets the name of the land class.'''
        self._name = name

    def set_description(self, description: str):
        '''Sets the description of the land class.'''
        self._description = description

    def get_class(self) -&gt; int:
        '''Gets the name of the land class.'''
        return self._land_class

    def get_name(self) -&gt; str:
        '''Gets the name of the land class.'''
        return self._name

    def get_description(self) -&gt; str:
        '''Gets the description of the land class.'''
        return self._description

#---------------------------------------------------------
# now shit gets real

headers = True #set true for first row of lookup table to get header indices
lc_idx = -1
lc_desc_idx = -1
fc_idx = -1

lc_idx_array = [] # a list of unique land indices. Used to prevent duplication.
fc_idx_array = [] # a list of unique fuel indices. Used to prevent duplication.
# lc_array = []
fc_array = []

with open(fileName) as f:
    lookup = csv.reader(f)
    header = True

    for row in lookup:
        if header:
            for i in range(len(row)):
                if row[i] == lc_header:
                    lc_idx = i
                elif row[i] == lc_description:
                    lc_desc_idx = i
                elif row[i] == fc_header:
                    fc_idx = i
        
            header = False

        else:
            if row[fc_idx] not in fc_idx_array: #need to create a new fuel class
                fc = FuelClass(row[fc_idx])
                fc_idx_array.append(row[fc_idx])
                fc_array.append(fc)
            
            if row[lc_idx] not in lc_idx_array: # need to create new land class
                lc = LandClass(row[lc_idx])
                if lc_desc_idx &gt; -1:
                    lc.set_description(row[lc_desc_idx])
                lc_idx_array.append(row[lc_idx])
                # lc_array.append(lc)

                # add the new land class to the relevant fuel class
                for fc in fc_array:
                    if fc.get_class() == row[fc_idx]:
                        fc.add_land_class(lc)
                
if DEBUG:
    #print out the list of fuel classes and their land classes                
    for fc in fc_array:
        land_class_str = ' '.join([str(elem.get_class()) for elem in fc.get_land_classes()]) 
        print(f'fuel class: {fc.get_class()}, land classes: {land_class_str}')

    print('\n\n')        

    
with open(fileName2) as s:
    s_lines = s.readlines()

for line in s_lines:
    initString += line
    
    if 'insert reclass rules here' in line:
        for fc in fc_array:
            for lc in fc.get_land_classes():
                initString += f'    case {lc.get_class()}:    // {lc.get_description()}\n'

            initString += f'        class = {fc.get_class()};    // {spread_models[int(fc.get_class())]}\n'
            initString += '        break;\n\n'

if DEBUG:
    with open('./Scripts/landclass_to_fuelclass.c', 'w') as f:
        f.write(initString)
        print('output to ./Scripts/landclass_to_fuelclass.c\n\n')</input>
  <input globalname="Initialisation end string"></input>
  <input globalname="Initialisation start string"></input>
  <input globalname="Output isochrone time">0</input>
  <input globalname="Output shape file">./Output/isochrone.shp</input>
  <input globalname="Output spot fire shape file"></input>
  <input globalname="Output raster file">./Output/arrival.tiff</input>
  <input globalname="Output data raster file">./Output/output.tiff</input>
  <input globalname="Output data raster type">6</input>
  <input globalname="Output stats layers">1</input>
  <input globalname="Output stats script"></input>
  <input globalname="Output stats unit type">0</input>
  <input globalname="Output stats raster file"></input>
  <input globalname="Output stats raster type">6</input>
  <input globalname="Output projection WKT">EPSG:4326</input>
  <input globalname="KML write">0</input>
  <input globalname="KML directory"></input>
  <input globalname="KML time step">0</input>
  <input globalname="Disruption shape source file"></input>
  <input globalname="Disruption shape projection WKT"></input>
  <input globalname="Disruption clear state">1</input>
  <input globalname="Disruption overwrite classification">0</input>
  <input globalname="Disruption overwrite classification value">0</input>
  <input globalname="Disruption overwrite user layer">0</input>
  <input globalname="Disruption overwrite user layer name"></input>
  <input globalname="Disruption overwrite network state name"></input>
  <input globalname="Firebrand active">0</input>
  <input globalname="Firebrand creation"></input>
  <input globalname="Firebrand update"></input>
  <input globalname="Firebrand growth"></input>
  <input globalname="Firebrand airbourne growth"></input>
  <input globalname="Potential active">0</input>
  <input globalname="Potential function parameter">0</input>
  <input globalname="Potential magnitude parameter">0</input>
  <input globalname="Potential elevation parameter">0</input>
  <input globalname="Potential elevation max height">0</input>
  <input globalname="Potential wind conversion">1</input>
  <input globalname="Wind correction active">0</input>
  <input globalname="Wind correction max height">0</input>
  <input globalname="Wind correction vertical layers">0</input>
  <input globalname="Wind correction parameter">0</input>
  <input globalname="RoS 1">// lnc_fc_grassland
// modified geoff.goldrick@protonmail.com 2020-08-18

// CSIRO grasslands models - Cheney et al. (1998)
// Subclasses defined as the following sub type of grasslands:
// 1 - Eaten out
// 2 - Cut / grazed
// 3 - Natural / undisturbed
// 4 - Woodland
// 5 - Open forest

// -------------------------------------------
// Model parameters
// 1. Temperature, 'temp'  (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Curing value, 'curing'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Equations are curve fits adapted from Taylor (1997)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else {
  LBR = 1.1*pow(wind_speed, 0.464);
}

// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters 
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate curing coefficient from Cruz et al. (2015)
REAL curing_coeff;
if ( curing &lt; 20 )
    curing_coeff = 0;
else
    curing_coeff = 1.036 / ( 1 + 103.989 * exp( -0.0996 * (curing - 20) ) );

// Fuel moisture content approximated using McArthur (1966)
REAL GMf = 9.58-(0.205*temp) + (0.138*rel_hum);

// Calculate moisture coefficient from Cheney et al. (1998)
REAL moisture_coeff;
if ( GMf &lt;= 12 ){
    moisture_coeff = exp( -0.108 * GMf );
} else if ( wind_speed &lt;= 10 ){
    moisture_coeff = 0.684 - 0.0342 * GMf; 
} else{
    moisture_coeff = 0.547 - 0.0228 * GMf;} 

// Defining coefficients for the various grasslands sub-types using different subclasses.
REAL head_speed; 
REAL CF_Backing_Slow; 
REAL CF_Backing_Fast; 
REAL CF_Wind_Slow; 
REAL CF_Wind_Fast; 
REAL speed_factor = 1; 

if (subclass == 1) // Eaten out 
    {
    CF_Backing_Slow = 0.027;
    CF_Backing_Fast = 0.55;
    CF_Wind_Slow = 0.1045; 
    CF_Wind_Fast = 0.3575;
    } 
else if (subclass == 2) // Cut or grazed 
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.1;
    CF_Wind_Slow = 0.209;
    CF_Wind_Fast = 0.715; 
    } 
else if (subclass == 3) // Natural or undisturbed
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    } 
else if (subclass == 4) // Woodland  
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.5; 
    } 
else if (subclass == 5) // Open forest
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.3;
    } 

// Calculate spread rate from Cheney et al. (1998) (converting spread rate to m/s from km/hr) 
if ( wind_speed &gt;= 5.0 )
    head_speed = (CF_Backing_Fast + CF_Wind_Fast * pow( (wind_speed - 5), 0.844 ) ) * moisture_coeff * curing_coeff / 3.6;
else
    head_speed = (CF_Backing_Slow + CF_Wind_Slow * wind_speed)* moisture_coeff * curing_coeff / 3.6; 

// Adjust speed based on canopy layer for Northern Australia grassland types (woodland and open forest) 
// Based on Cheney and Sullivan (2008)
head_speed = head_speed * speed_factor;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 2">// lnc_fc_woodlands
// modified geoff.goldrick@protonmail.com 2020-08-18

// CSIRO grasslands models - Cheney et al. (1998)
// Subclasses defined as the following sub type of grasslands:
// 1 - Eaten out
// 2 - Cut / grazed
// 3 - Natural / undisturbed
// 4 - Woodland
// 5 - Open forest

// -------------------------------------------
// Model parameters
// 1. Temperature, 'temp'  (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Curing value, 'curing'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Equations are curve fits adapted from Taylor (1997)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else {
  LBR = 1.1*pow(wind_speed, 0.464);
}

// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters 
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate curing coefficient from Cruz et al. (2015)
REAL curing_coeff;
if ( curing &lt; 20 )
    curing_coeff = 0;
else
    curing_coeff = 1.036 / ( 1 + 103.989 * exp( -0.0996 * (curing - 20) ) );

// Fuel moisture content approximated using McArthur (1966)
REAL GMf = 9.58-(0.205*temp) + (0.138*rel_hum);

// Calculate moisture coefficient from Cheney et al. (1998)
REAL moisture_coeff;
if ( GMf &lt;= 12 ){
    moisture_coeff = exp( -0.108 * GMf );
} else if ( wind_speed &lt;= 10 ){
    moisture_coeff = 0.684 - 0.0342 * GMf; 
} else{
    moisture_coeff = 0.547 - 0.0228 * GMf;} 

// Defining coefficients for the various grasslands sub-types using different subclasses.
REAL head_speed; 
REAL CF_Backing_Slow; 
REAL CF_Backing_Fast; 
REAL CF_Wind_Slow; 
REAL CF_Wind_Fast; 
REAL speed_factor = 1; 

if (subclass == 1) // Eaten out 
    {
    CF_Backing_Slow = 0.027;
    CF_Backing_Fast = 0.55;
    CF_Wind_Slow = 0.1045; 
    CF_Wind_Fast = 0.3575;
    } 
else if (subclass == 2) // Cut or grazed 
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.1;
    CF_Wind_Slow = 0.209;
    CF_Wind_Fast = 0.715; 
    } 
else if (subclass == 3) // Natural or undisturbed
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    } 
else if (subclass == 4) // Woodland  
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.5; 
    } 
else if (subclass == 5) // Open forest
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.3;
    } 

// Calculate spread rate from Cheney et al. (1998) (converting spread rate to m/s from km/hr) 
if ( wind_speed &gt;= 5.0 )
    head_speed = (CF_Backing_Fast + CF_Wind_Fast * pow( (wind_speed - 5), 0.844 ) ) * moisture_coeff * curing_coeff / 3.6;
else
    head_speed = (CF_Backing_Slow + CF_Wind_Slow * wind_speed)* moisture_coeff * curing_coeff / 3.6; 

// Adjust speed based on canopy layer for Northern Australia grassland types (woodland and open forest) 
// Based on Cheney and Sullivan (2008)
head_speed = head_speed * speed_factor;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 3">// lnc_fc_sclerophyll_dry
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 4">// lnc_fc_sclerophyll_wet
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Wet Eucalypt model - Adapted from Project VESTA
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// 6. Shrub height, 'fuel_height'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010)
// Initialising the fuel moisture variable
REAL Mf;

// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March)
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);}

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example
else{
    Mf =  3.08 + (0.198*rel_hum) - (0.0483*temp);}  

// Applying wind reduction factors and fuel moisture modifications for wet forest as per Amicus
// These factors depend on the height of the shrubs within the forest
if (fuel_height &lt; 2){
    wind_speed = wind_speed / 2;
    Mf = Mf + 0.2052*Mf + 0.8554;}
else if (fuel_height &gt; 5){
    wind_speed = wind_speed / 3;
    Mf = Mf + 0.5923*Mf + 1.9565;}
else{
    wind_speed = wind_speed / 2.3;
    Mf = Mf + 0.5248*Mf - 0.0568;}

// Calculate moisture coefficients from Burrows (1999)
REAL moisture_coeff = 18.35 * pow(Mf,-1.495);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Using the reduced under canopy wind speed in this case
// Equations are curve fits adapted from Taylor (1997)
REAL LBR;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else if (wind_speed &lt; 25){
  LBR = 0.9286 * exp(0.0505 * wind_speed);
} else {
  LBR = 0.1143 * wind_speed + 0.4143;
}
// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate head fire spread rate (in m/s)
REAL head_speed;
if ( wind_speed &gt; 5 ){
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
} else {
  head_speed = 30.0 * moisture_coeff/3600;}

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 5">// lnc_fc_rainforest
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Wet Eucalypt model - Adapted from Project VESTA
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// 6. Shrub height, 'fuel_height'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010)
// Initialising the fuel moisture variable
REAL Mf;

// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March)
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);}

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example
else{
    Mf =  3.08 + (0.198*rel_hum) - (0.0483*temp);}  

// Applying wind reduction factors and fuel moisture modifications for wet forest as per Amicus
// These factors depend on the height of the shrubs within the forest
if (fuel_height &lt; 2){
    wind_speed = wind_speed / 2;
    Mf = Mf + 0.2052*Mf + 0.8554;}
else if (fuel_height &gt; 5){
    wind_speed = wind_speed / 3;
    Mf = Mf + 0.5923*Mf + 1.9565;}
else{
    wind_speed = wind_speed / 2.3;
    Mf = Mf + 0.5248*Mf - 0.0568;}

// Calculate moisture coefficients from Burrows (1999)
REAL moisture_coeff = 18.35 * pow(Mf,-1.495);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Using the reduced under canopy wind speed in this case
// Equations are curve fits adapted from Taylor (1997)
REAL LBR;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else if (wind_speed &lt; 25){
  LBR = 0.9286 * exp(0.0505 * wind_speed);
} else {
  LBR = 0.1143 * wind_speed + 0.4143;
}
// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate head fire spread rate (in m/s)
REAL head_speed;
if ( wind_speed &gt; 5 ){
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
} else {
  head_speed = 30.0 * moisture_coeff/3600;}

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 6">// lnc_fc_other_forest
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 7">// lnc_fc_heath_coastal
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Heathland model - Anderson et al. (2015)
// Model parameters
// These must be defined below, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
// 4. Average fuel height, 'fuel_height' (input)
// 5. Rate of spread for zero wind, 'R0' (input), recommended as 5 m/min.
// 6. Solar radiation factor, 'delta' (input), {0,1}, delta = 1 for sunny days from 12:00 - 17:00 from October to March (high solar radiation) and 0 otherwise.
// -------------------------------------------

//Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
float WF = 0.67;
int R0 = 5;

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) for grassland
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0; 
} else { 
    LBR = 1.1*pow(wind_speed, 0.464); 
} 

// Determine coefficient for flank rank of spread
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0); 
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Initialising the solar radiation variable 
REAL delta; 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    delta = 1;}
else {
    delta = 0;}

// Calculating moisture content 
REAL MC = 4.37 + 0.161*rel_hum - 0.1*(temp - 25) - delta * 0.027 * rel_hum;

REAL head_speed;
// Calculating rate of spread in m/min
if (wind_speed &lt; 5){
    head_speed = (R0 + 0.2*(5.67*pow(5*WF, 0.91) - R0)*wind_speed) * pow(fuel_height, 0.22) * exp(-0.076*MC);
} else {
    head_speed = 5.67 * pow(WF*wind_speed, 0.91) * pow(fuel_height, 0.22) * exp(-0.076*MC); }

// Converting spread rate into m/s
head_speed = head_speed / 60;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 8">// lnc_fc_heath_semi_arid
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Heathland model - Anderson et al. (2015)
// Model parameters
// These must be defined below, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
// 4. Average fuel height, 'fuel_height' (input)
// 5. Rate of spread for zero wind, 'R0' (input), recommended as 5 m/min.
// 6. Solar radiation factor, 'delta' (input), {0,1}, delta = 1 for sunny days from 12:00 - 17:00 from October to March (high solar radiation) and 0 otherwise.
// -------------------------------------------

//Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
float WF = 0.67;
int R0 = 5;

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) for grassland
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0; 
} else { 
    LBR = 1.1*pow(wind_speed, 0.464); 
} 

// Determine coefficient for flank rank of spread
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0); 
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Initialising the solar radiation variable 
REAL delta; 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    delta = 1;}
else {
    delta = 0;}

// Calculating moisture content 
REAL MC = 4.37 + 0.161*rel_hum - 0.1*(temp - 25) - delta * 0.027 * rel_hum;

REAL head_speed;
// Calculating rate of spread in m/min
if (wind_speed &lt; 5){
    head_speed = (R0 + 0.2*(5.67*pow(5*WF, 0.91) - R0)*wind_speed) * pow(fuel_height, 0.22) * exp(-0.076*MC);
} else {
    head_speed = 5.67 * pow(WF*wind_speed, 0.91) * pow(fuel_height, 0.22) * exp(-0.076*MC); }

// Converting spread rate into m/s
head_speed = head_speed / 60;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 9">// lnc_fc_pine
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 10">// fc_moorlands

speed = 0.01;</input>
  <input globalname="RoS 11">// fc_wetlands

speed = 0.01;</input>
  <input globalname="RoS 12">// fc_urban = 12;

speed = 0.1;</input>
  <input globalname="Reduction slice">0</input>
  <input globalname="Reduction slice 2">0</input>
  <input globalname="Reduction slice 3">0</input>
  <input globalname="Reduction type">0</input>
  <input globalname="Reduction type 2">0</input>
  <input globalname="Reduction type 3">0</input>
  <input globalname="Reduction script"></input>
  <input globalname="Output header">// Output layers:
//   0: arrival time (s)
//   1: speed (m/s)
//   2: Maximum intensity (kW/m)
//   3: Maximum flame height (m)
//   4: Class
//   5: Vegetation Type
//   6: Unused
//   7: Unused
//   8: Wind vector x-component
//   9: Wind vector y-component

// One-time variables
if (output0 == nodata) {

    output0 = arrival;
    output1 = speed;
    output2 = 0.0;
    output3 = 0.0;
    output4 = class;
    output8 = wind_vector.x;
    output9 = wind_vector.y;
}

// Calculate intensity and flame height
REAL intensity = 18600*speed*fuel_load*0.1;
REAL flame_height = 0.0775*pow(intensity, 0.46);

output2 = max(output2, intensity);
output3 = max(output3, flame_height);</input>
  <input globalname="Output 1"></input>
  <input globalname="Output 2"></input>
  <input globalname="Output 3"></input>
  <input globalname="Output 4"></input>
  <input globalname="Output 5"></input>
  <input globalname="Output 6"></input>
  <input globalname="Output 7"></input>
  <input globalname="Output 8"></input>
  <input globalname="Output 9"></input>
  <input globalname="Output 10"></input>
  <input globalname="Output 11"></input>
  <input globalname="Output 12"></input>
  <input globalname="Project name">LNC_latest_py</input>
  <input globalname="PostGIS database name"></input>
  <input globalname="PostGIS host name"></input>
  <input globalname="PostGIS schema name"></input>
  <input globalname="PostGIS table name"></input>
  <input globalname="PostGIS user name"></input>
  <input globalname="PostGIS create script"></input>
  <input globalname="PostGIS append script"></input>
  <input globalname="Vertical levels">1</input>
  <input globalname="Vertical level spacing">0</input>
  <input globalname="Shape file input source">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Input/ignitions/lni_ignition_latest.shp</input>
  <input globalname="GeoJSON input source">{
    &quot;features&quot;: [
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.88521429550187,
                        -30.582142694892717
                    ],
                    [
                        152.88669522549063,
                        -30.581587346146936
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;valley valley 1&quot;,
                &quot;date&quot;: &quot;20200824&quot;,
                &quot;id&quot;: 2
            },
            &quot;type&quot;: &quot;Feature&quot;
        },
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.90057894413513,
                        -30.58189587322793
                    ],
                    [
                        152.90156623079432,
                        -30.58294486530329
                    ],
                    [
                        152.9021832849563,
                        -30.583438508632874
                    ],
                    [
                        152.90286204453446,
                        -30.58411726821105
                    ],
                    [
                        152.90354080411265,
                        -30.584857733205425
                    ],
                    [
                        152.90323227703166,
                        -30.585413081951206
                    ],
                    [
                        152.90286204453446,
                        -30.586030136113184
                    ],
                    [
                        152.90286204453446,
                        -30.586030136113184
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;valley valley 2&quot;,
                &quot;date&quot;: &quot;20200824&quot;,
                &quot;id&quot;: 3
            },
            &quot;type&quot;: &quot;Feature&quot;
        },
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.89706173541185,
                        -30.572825177046838
                    ],
                    [
                        152.89767878957383,
                        -30.57239323913345
                    ],
                    [
                        152.89848095998443,
                        -30.57183789038767
                    ],
                    [
                        152.89848095998443,
                        -30.57183789038767
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;valley valley 3&quot;,
                &quot;date&quot;: &quot;20200824&quot;,
                &quot;id&quot;: 4
            },
            &quot;type&quot;: &quot;Feature&quot;
        },
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.887435690485,
                        -30.577267967013086
                    ],
                    [
                        152.88786762839837,
                        -30.57634238577012
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;valley valley 05&quot;,
                &quot;date&quot;: &quot;20200824&quot;,
                &quot;id&quot;: 5
            },
            &quot;type&quot;: &quot;Feature&quot;
        },
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.84853042557225,
                        -31.019649522089793
                    ],
                    [
                        152.84812934036697,
                        -31.01906332063591
                    ],
                    [
                        152.84771282880763,
                        -31.018662235430625
                    ],
                    [
                        152.8472346118321,
                        -31.018399987411783
                    ],
                    [
                        152.84661755767013,
                        -31.018399987411783
                    ],
                    [
                        152.84601592986218,
                        -31.01880107261707
                    ],
                    [
                        152.84553771288665,
                        -31.019310142300704
                    ],
                    [
                        152.84563027101095,
                        -31.019772932922187
                    ],
                    [
                        152.84630903058914,
                        -31.020189444481524
                    ],
                    [
                        152.8471420537078,
                        -31.020420839792266
                    ],
                    [
                        152.8477591078698,
                        -31.020312855313918
                    ],
                    [
                        152.84862298369654,
                        -31.020174018127474
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;collobatti&quot;,
                &quot;date&quot;: &quot;20200825&quot;,
                &quot;id&quot;: 7
            },
            &quot;type&quot;: &quot;Feature&quot;
        },
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    [
                        152.7407156371204,
                        -31.12113950538149
                    ],
                    [
                        152.74170292377954,
                        -31.12113950538149
                    ]
                ],
                &quot;type&quot;: &quot;LineString&quot;
            },
            &quot;properties&quot;: {
                &quot;Name&quot;: &quot;dondingalong&quot;,
                &quot;date&quot;: &quot;20200825&quot;,
                &quot;id&quot;: 2108
            },
            &quot;type&quot;: &quot;Feature&quot;
        }
    ],
    &quot;type&quot;: &quot;FeatureCollection&quot;
}
</input>
  <input globalname="Simulation number script"></input>
  <input globalname="Simulation duration hours">24</input>
  <input globalname="Simulation projection WKT">EPSG:28356</input>
  <input globalname="Simulation resolution">30</input>
  <input globalname="Start point script"></input>
  <input globalname="Start condition projection WKT">EPSG:4326</input>
  <input globalname="Start time">2020-08-25T06:00:00+10:00</input>
  <input globalname="End time"></input>
  <input globalname="Number of simulations">0</input>
  <input globalname="Random seed">0</input>
  <input globalname="Verbose">0</input>
  <input globalname="Gridded/Relative humidity/Layer scheme">0</input>
  <input globalname="Gridded/Relative humidity/Layer opacity">1</input>
  <input globalname="Gridded/Temperature/Layer scheme">0</input>
  <input globalname="Gridded/Temperature/Layer opacity">1</input>
  <input globalname="Gridded/Dew point temperature/Layer scheme">0</input>
  <input globalname="Gridded/Dew point temperature/Layer opacity">1</input>
  <input globalname="Gridded/Drought factor/Layer scheme">0</input>
  <input globalname="Gridded/Drought factor/Layer opacity">1</input>
  <input globalname="Map operational shape source file"></input>
  <input globalname="Map asset shape source file"></input>
  <input globalname="Map shape projection WKT"></input>
  <input globalname="Slippy map URL">https://tile.openstreetmap.org/</input>
  <input globalname="Slippy map transpose">0</input>
  <input globalname="Slippy map text">OpenStreetMap contributors</input>
  <input globalname="Slippy map proxy"></input>
  <input globalname="Slippy map port">0</input>
  <input globalname="Slippy map reproject">0</input>
  <input globalname="View isochrone colour" rgba="4282400832"/>
  <input globalname="View isochrone fill type">1</input>
  <input globalname="Comparison output raster file"></input>
</operation>
