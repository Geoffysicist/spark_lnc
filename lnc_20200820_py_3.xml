<?xml version="1.0" encoding="UTF-8"?>
<operation>
  <input globalname="Bounding box">
    <CRS>EPSG:4326</CRS>
    <minx>152.19999999999999</minx>
    <miny>-31.399999999999999</miny>
    <maxx>153.19999999999999</maxx>
    <maxy>-30.399999999999999</maxy>
    <resx>0</resx>
    <resy>0</resy>
  </input>
  <input globalname="Bounding box toggle">1</input>
  <input globalname="Bounding box buffer">0.5</input>
  <input globalname="Bounding box auto toggle">0</input>
  <input globalname="Curing/Layer default">50</input>
  <input globalname="Curing/Layer projection WKT"></input>
  <input globalname="Curing/Layer source file"></input>
  <input globalname="Curing/Layer interpolation">1</input>
  <input globalname="Elevation/Layer default">0</input>
  <input globalname="Elevation/Layer projection WKT">EPSG:28356</input>
  <input globalname="Elevation/Layer source file">./Input/LNC_DEM_MGA94_56/LNC_DEM_MGA94_56.tif</input>
  <input globalname="Elevation/Layer interpolation">1</input>
  <input globalname="Fire history/Layer default">2</input>
  <input globalname="Fire history/Layer projection WKT"></input>
  <input globalname="Fire history/Layer source file"></input>
  <input globalname="Fire history/Layer interpolation">1</input>
  <input globalname="Fuel load/Layer default">0</input>
  <input globalname="Fuel load/Layer projection WKT"></input>
  <input globalname="Fuel load/Layer source file"></input>
  <input globalname="Fuel load/Layer interpolation">1</input>
  <input globalname="Classification/Layer projection WKT">EPSG:4326</input>
  <input globalname="Classification/Layer source file">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Input/LNC_Vegetation_gda94_latlon/LNC_vegetation_GDA94_latlon.tif</input>
  <input globalname="Classification/Shape mask projection WKT"></input>
  <input globalname="Classification/Shape mask source file"></input>
  <input globalname="Classification/Shape mask GeoJSON"></input>
  <input globalname="Classification/Shape mask state name"></input>
  <input globalname="Gridded/Source directory"></input>
  <input globalname="Gridded/Layer projection WKT"></input>
  <input globalname="Gridded/Start time overwrite"></input>
  <input globalname="Gridded/Time conversion coefficient">0</input>
  <input globalname="Gridded/Wind/Layer direction source file"></input>
  <input globalname="Gridded/Wind/Layer direction source filter"></input>
  <input globalname="Gridded/Wind/Layer direction scale">0</input>
  <input globalname="Gridded/Wind/Layer direction offset">0</input>
  <input globalname="Gridded/Wind/Use direction speed">1</input>
  <input globalname="Gridded/Wind/Layer magnitude source file"></input>
  <input globalname="Gridded/Wind/Layer magnitude source filter"></input>
  <input globalname="Gridded/Wind/Layer magnitude scale">0</input>
  <input globalname="Gridded/Wind/Layer magnitude offset">0</input>
  <input globalname="Gridded/Relative humidity/Layer source file"></input>
  <input globalname="Gridded/Relative humidity/Layer source filter"></input>
  <input globalname="Gridded/Relative humidity/Layer scale">0</input>
  <input globalname="Gridded/Relative humidity/Layer offset">0</input>
  <input globalname="Gridded/Temperature/Layer source file"></input>
  <input globalname="Gridded/Temperature/Layer source filter"></input>
  <input globalname="Gridded/Temperature/Layer scale">0</input>
  <input globalname="Gridded/Temperature/Layer offset">0</input>
  <input globalname="Gridded/Dew point temperature/Layer source file"></input>
  <input globalname="Gridded/Dew point temperature/Layer source filter"></input>
  <input globalname="Gridded/Dew point temperature/Layer scale">0</input>
  <input globalname="Gridded/Dew point temperature/Layer offset">0</input>
  <input globalname="Gridded/Drought factor/Layer source file"></input>
  <input globalname="Gridded/Drought factor/Layer source filter"></input>
  <input globalname="Gridded/Drought factor/Layer scale">0</input>
  <input globalname="Gridded/Drought factor/Layer offset">0</input>
  <input globalname="Custom/Layer name 1">fhs_surface</input>
  <input globalname="Custom/Layer name 2">fhs_near_surface</input>
  <input globalname="Custom/Layer name 3">h_near_surface</input>
  <input globalname="Custom/Layer name 4">fuel_height</input>
  <input globalname="Custom/Layer name 5"></input>
  <input globalname="Custom/Layer name 6"></input>
  <input globalname="Custom/Layer name 7"></input>
  <input globalname="Custom/Layer name 8"></input>
  <input globalname="Custom/Layer name 9"></input>
  <input globalname="Custom/Layer name 10"></input>
  <input globalname="Custom/Layer name 11"></input>
  <input globalname="Custom/Layer name 12"></input>
  <input globalname="Custom/Layer name 13"></input>
  <input globalname="Custom/Layer name 14"></input>
  <input globalname="Custom/Layer name 15"></input>
  <input globalname="Custom/Layer name 16"></input>
  <input globalname="Custom/Layer name 17"></input>
  <input globalname="Custom/Layer name 18"></input>
  <input globalname="Custom/Layer name 19"></input>
  <input globalname="Custom/Layer name 20"></input>
  <input globalname="Custom/Layer default 1">0</input>
  <input globalname="Custom/Layer default 2">0</input>
  <input globalname="Custom/Layer default 3">0</input>
  <input globalname="Custom/Layer default 4">1.5</input>
  <input globalname="Custom/Layer default 5">0</input>
  <input globalname="Custom/Layer default 6">0</input>
  <input globalname="Custom/Layer default 7">0</input>
  <input globalname="Custom/Layer default 8">0</input>
  <input globalname="Custom/Layer default 9">0</input>
  <input globalname="Custom/Layer default 10">0</input>
  <input globalname="Custom/Layer default 11">0</input>
  <input globalname="Custom/Layer default 12">0</input>
  <input globalname="Custom/Layer default 13">0</input>
  <input globalname="Custom/Layer default 14">0</input>
  <input globalname="Custom/Layer default 15">0</input>
  <input globalname="Custom/Layer default 16">0</input>
  <input globalname="Custom/Layer default 17">0</input>
  <input globalname="Custom/Layer default 18">0</input>
  <input globalname="Custom/Layer default 19">0</input>
  <input globalname="Custom/Layer default 20">0</input>
  <input globalname="Custom/Layer file name 1"></input>
  <input globalname="Custom/Layer file name 2"></input>
  <input globalname="Custom/Layer file name 3"></input>
  <input globalname="Custom/Layer file name 4"></input>
  <input globalname="Custom/Layer file name 5"></input>
  <input globalname="Custom/Layer file name 6"></input>
  <input globalname="Custom/Layer file name 7"></input>
  <input globalname="Custom/Layer file name 8"></input>
  <input globalname="Custom/Layer file name 9"></input>
  <input globalname="Custom/Layer file name 10"></input>
  <input globalname="Custom/Layer file name 11"></input>
  <input globalname="Custom/Layer file name 12"></input>
  <input globalname="Custom/Layer file name 13"></input>
  <input globalname="Custom/Layer file name 14"></input>
  <input globalname="Custom/Layer file name 15"></input>
  <input globalname="Custom/Layer file name 16"></input>
  <input globalname="Custom/Layer file name 17"></input>
  <input globalname="Custom/Layer file name 18"></input>
  <input globalname="Custom/Layer file name 19"></input>
  <input globalname="Custom/Layer file name 20"></input>
  <input globalname="Custom/Layer projection 1"></input>
  <input globalname="Custom/Layer projection 2"></input>
  <input globalname="Custom/Layer projection 3"></input>
  <input globalname="Custom/Layer projection 4"></input>
  <input globalname="Custom/Layer projection 5"></input>
  <input globalname="Custom/Layer projection 6"></input>
  <input globalname="Custom/Layer projection 7"></input>
  <input globalname="Custom/Layer projection 8"></input>
  <input globalname="Custom/Layer projection 9"></input>
  <input globalname="Custom/Layer projection 10"></input>
  <input globalname="Custom/Layer projection 11"></input>
  <input globalname="Custom/Layer projection 12"></input>
  <input globalname="Custom/Layer projection 13"></input>
  <input globalname="Custom/Layer projection 14"></input>
  <input globalname="Custom/Layer projection 15"></input>
  <input globalname="Custom/Layer projection 16"></input>
  <input globalname="Custom/Layer projection 17"></input>
  <input globalname="Custom/Layer projection 18"></input>
  <input globalname="Custom/Layer projection 19"></input>
  <input globalname="Custom/Layer projection 20"></input>
  <input globalname="Custom/Layer interpolation 1">0</input>
  <input globalname="Custom/Layer interpolation 2">0</input>
  <input globalname="Custom/Layer interpolation 3">0</input>
  <input globalname="Custom/Layer interpolation 4">0</input>
  <input globalname="Custom/Layer interpolation 5">0</input>
  <input globalname="Custom/Layer interpolation 6">0</input>
  <input globalname="Custom/Layer interpolation 7">0</input>
  <input globalname="Custom/Layer interpolation 8">0</input>
  <input globalname="Custom/Layer interpolation 9">0</input>
  <input globalname="Custom/Layer interpolation 10">0</input>
  <input globalname="Custom/Layer interpolation 11">0</input>
  <input globalname="Custom/Layer interpolation 12">0</input>
  <input globalname="Custom/Layer interpolation 13">0</input>
  <input globalname="Custom/Layer interpolation 14">0</input>
  <input globalname="Custom/Layer interpolation 15">0</input>
  <input globalname="Custom/Layer interpolation 16">0</input>
  <input globalname="Custom/Layer interpolation 17">0</input>
  <input globalname="Custom/Layer interpolation 18">0</input>
  <input globalname="Custom/Layer interpolation 19">0</input>
  <input globalname="Custom/Layer interpolation 20">0</input>
  <input globalname="Series/Script">&quot;&quot;&quot;bom_point_forecasts - reads a time series of weather data from a BOM Point Forecast csv file.

Inputs from Spark:
fileName      pathname of the input csv file
timeZone      UTC offset eg. +11:00

Variables read from csv file - order of columns:
date          Local Date 'DD Mmm YYY'
time          Local Time 'HH:MM'
temp          Air temperature 'Temp (C)'
rel_hum       Relative humidity 'RH (%)'.
wind_speed    Wind speed 'Wind Speed (km/h)'.
wind_dir      Wind bearing in degrees 'Wind Dir'.
drought_fac   'Drought factor' (1-10).
ffdi          Forest Fire Danger Index 'FFDI'
gfdi          Grass Fire Danger Index 'GFDI'.


If debugging outside of Spark must set input varriables

&quot;&quot;&quot;
import csv
import datetime as dt

months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']


DEBUG = False  #set to True if debugging outside of Spark

# set input variables if debugging outside of Spark
if DEBUG:
    fileName = &quot;./Input/weather_series/2020-08-21-08-08-07_PointForecast.csv&quot;
    timeZone = &quot;+10:00&quot;
    time = []
    wind_speed = []
    wind_dir = []
    temp = []
    rel_hum = []
    dew_temp = []
    drought_fac = []





with open(fileName) as f:
    weather = csv.reader(f)
    header = True
    series_array = [temp, rel_hum, wind_dir, wind_speed, drought_fac]
    
    for row in weather:
        try:
            d = row[0].split(' ')
            date = dt.date(int(d[2]), int(months.index(d[1])+1), int(d[0]))
            weather_data = row[2:]
            time.append(f'{date.isoformat()}T{row[1]}:00{timeZone}')
            for i in range(len(series_array)):
                series_array[i].append(weather_data[i])


        except IndexError: # not a date of type &quot;DD Mmm YYYY&quot;            
            if DEBUG: print('not a date')
        
            # populate series


if DEBUG:
    for t in range(len(time)):
        print(time[t], end='\t')
        for r in range(len(series_array)):
            try:
                print(f&quot;{series_array[r][t]}&quot;, end=&quot;\t&quot;)
            except IndexError:
                print(&quot;&quot;, end=&quot;\t&quot;)
        print('')</input>
  <input globalname="Series/Source file">C:/Users/ggoldrick/Documents/GitHub/Geoffysicist/spark_lnc/Input/weather_series/2020-08-22-11-49-32_PointForecast.csv</input>
  <input globalname="Series/Time zone">+10:00</input>
  <input globalname="Series/Wind speed stdev">0</input>
  <input globalname="Series/Wind bearing stdev">0</input>
  <input globalname="Initialisation Python input file"></input>
  <input globalname="Initialisation Python input file 2"></input>
  <input globalname="Initialisation Python script">import json

# Write to JSON
JSON = {
    &quot;Layers&quot;: [
        {
            &quot;Name&quot;: &quot;Arrival time (s)&quot;
        },
        {
            &quot;Name&quot;: &quot;Speed (m/s)&quot;
        },
        {
            &quot;Name&quot;: &quot;Maximum intensity (kW/m)&quot;
        },
        {
            &quot;Name&quot;: &quot;Maximum flame height (m)&quot;
        },
        {
            &quot;Name&quot;: &quot;Class&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Unused&quot;
        },
        {
            &quot;Name&quot;: &quot;Wind x-velocity&quot;
        },
        {
            &quot;Name&quot;: &quot;Wind y-velocity&quot;
        }
    ]
}
outputJSON = json.dumps(JSON)</input>
  <input globalname="Initialisation end string"></input>
  <input globalname="Initialisation start string">// Reclassify veg types into fuel classes
// 
// Define the fuel classes

short fc_grassland = 1;
short fc_woodland = 2;
short fc_sclerophyll_dry = 3;
short fc_sclerophyll_wet = 3; //TODO change back to 4
short fc_rainforest = 5;
short fc_other_forest = 6;
short fc_heath_coastal = 7;
short fc_heath_semi_arid = 8;
short fc_pine = 9;
short fc_moorlands = 10;
short fc_wetlands = 11;
short fc_urban = 12;



switch(class)
{
    case 156:    // Cleared
    case 327:    // Cleared
    case 344:    // Cleared
    case 501:    // Cleared
    case 560:    // Cleared
    case 642:    // Cleared
    case 1038:    // Cleared
    case 515:    // MaritimeGrasslands
    case 596:    // MaritimeGrasslands
    case 1054:    // MaritimeGrasslands
        class = fc_grassland;
        break;

    case 610:    // TablelandClayGrassyWoodlands
    case 342:    // CoastalValleyGrassyWoodlands
    case 350:    // CoastalValleyGrassyWoodlands
    case 513:    // CoastalValleyGrassyWoodlands
    case 594:    // CoastalValleyGrassyWoodlands
        class = fc_woodland;
        break;
    
    case 331:    // CoastalDuneDrySclerophyllForests
    case 506:    // CoastalDuneDrySclerophyllForests
    case 570:    // CoastalDuneDrySclerophyllForests
    case 603:    // CoastalDuneDrySclerophyllForests
    case 656:    // CoastalDuneDrySclerophyllForests
    case 1042:    // CoastalDuneDrySclerophyllForests
    case 332:    // NorthCoastDrySclerophyllForests
    case 573:    // NorthernEscarpmentDrySclerophyllForests
    case 574:    // NorthernTablelandDrySclerophyllForests
    case 160:    // CoastalFloodplainForests
    case 509:    // CoastalFloodplainForests
    case 582:    // CoastalFloodplainForests
    case 614:    // CoastalFloodplainForests
    case 675:    // CoastalFloodplainForests
    case 348:    // EasternRiverineForests
    case 583:    // EasternRiverineForests
    case 588:    // NorthernGorgeDrySclerophyllForests
    case 618:    // NorthernGorgeDrySclerophyllForests
    case 326:    // Hunter-MacleayDrySclerophyllForests
    case 339:    // Hunter-MacleayDrySclerophyllForests
    case 349:    // Hunter-MacleayDrySclerophyllForests
    case 511:    // Hunter-MacleayDrySclerophyllForests
    case 591:    // Hunter-MacleayDrySclerophyllForests
       class = fc_sclerophyll_dry;
        break;

    case 330:    // NorthCoastWetSclerophyllForests
    case 345:    // NorthCoastWetSclerophyllForests
    case 505:    // NorthCoastWetSclerophyllForests
    case 540:    // NorthCoastWetSclerophyllForests
    case 566:    // NorthCoastWetSclerophyllForests
    case 599:    // NorthCoastWetSclerophyllForests
    case 647:    // NorthCoastWetSclerophyllForests
    case 1041:    // NorthCoastWetSclerophyllForests
    case 346:    // NorthernEscarpmentWetSclerophyllForests
    case 541:    // NorthernEscarpmentWetSclerophyllForests
    case 567:    // NorthernEscarpmentWetSclerophyllForests
    case 600:    // NorthernEscarpmentWetSclerophyllForests
    case 542:    // NorthernTablelandWetSclerophyllForests
    case 568:    // NorthernTablelandWetSclerophyllForests
    case 601:    // NorthernTablelandWetSclerophyllForests
    case 333:    // NorthernHinterlandWetSclerophyllForests
    case 347:    // NorthernHinterlandWetSclerophyllForests
    case 507:    // NorthernHinterlandWetSclerophyllForests
    case 543:    // NorthernHinterlandWetSclerophyllForests
    case 572:    // NorthernHinterlandWetSclerophyllForests
    case 605:    // NorthernHinterlandWetSclerophyllForests
    case 657:    // NorthernHinterlandWetSclerophyllForests
    case 1044:    // NorthernHinterlandWetSclerophyllForests
        class = fc_sclerophyll_wet;
        break;
    
    case 334:    // WallumSandHeaths
    case 576:    // WallumSandHeaths
    case 1045:    // WallumSandHeaths
    case 510:    // CoastalHeathSwamps
    case 584:    // CoastalHeathSwamps
    case 1048:    // CoastalHeathSwamps
    case 340:    // CoastalHeadlandandForeduneScrubs
    case 1052:    // CoastalHeadlandandForeduneScrubs
        class = fc_heath_coastal;  // Coastal Heath
        break;
    
    case 158:    // SubtropicalRainforests
    case 328:    // SubtropicalRainforests
    case 502:    // SubtropicalRainforests
    case 536:    // SubtropicalRainforests
    case 555:    // SubtropicalRainforests
    case 561:    // SubtropicalRainforests
    case 598:    // SubtropicalRainforests
    case 503:    // NorthernWarmTemperateRainforests
    case 537:    // NorthernWarmTemperateRainforests
    case 556:    // NorthernWarmTemperateRainforests
    case 562:    // NorthernWarmTemperateRainforests
    case 538:    // CoolTemperateRainforests
    case 557:    // CoolTemperateRainforests
    case 539:    // DryRainforests
    case 558:    // DryRainforests
    case 564:    // DryRainforests
    case 329:    // LittoralRainforests
    case 504:    // LittoralRainforests
    case 559:    // LittoralRainforests
    case 1040:    // LittoralRainforests
        class = fc_rainforest;
        break;

    case 544:    // NorthernMontaneHeaths
    case 159:    // CoastalSwampForests
    case 335:    // CoastalSwampForests
    case 508:    // CoastalSwampForests
    case 581:    // CoastalSwampForests
    case 1046:    // CoastalSwampForests
        class = fc_other_forest;
        break;

    case 161:    // CoastalFreshwaterLagoonsandFloodplainMeadows
    case 337:    // CoastalFreshwaterLagoonsandFloodplainMeadows
    case 1049:    // CoastalFreshwaterLagoonsandFloodplainMeadows
    case 211:    // MangroveSwamps
    case 338:    // MangroveSwamps
    case 586:    // MangroveSwamps
    case 681:    // MangroveSwamps
    case 212:    // Saltmarshes
    case 341:    // Saltmarshes
    case 512:    // Saltmarshes
    case 691:    // Saltmarshes
    case 1053:    // Saltmarshes
    case 213:    // SeagrassMeadows
    case 514:    // SeagrassMeadows
    case 711:    // SeagrassMeadows
    case 597:    // TemperateSwampForests
    case 343:    // Floodplain-EstuarineTransitionForests
    case 351:    // Floodplain-EstuarineTransitionForests
        class = fc_wetlands;
        break;
    
    case 336:    // MontaneBogsandFens
        class = fc_moorlands;
        break;

    default:    // Won't burn or no data
        class = 0;
}

//Initialise the custom inputs for the Dry Schlorophyll model
// modified geoff.goldrick@protonmail.com 2020-08-18 

// Set dry eucalypt parameters
bool useExponential = false;
bool useTall = true;
if (useExponential) {

  // Gould 2011 exponential model, uses fire_history in years
  if (useTall) {

    // Tall shrub
    fhs_surface = 3.39*(1-exp(-0.030*fire_history*12));
    fhs_near_surface = 2.95*(1-exp(-0.022*fire_history*12));
    h_near_surface = 23.33*(1-exp(-0.025*fire_history*12));

  } else {

    // Low shrub
    fhs_surface = 3.33*(1-exp(-1*0.035*fire_history*12));
    fhs_near_surface = 2.81*(1-exp(-1*0.018*fire_history*12));
    h_near_surface = 20.02*(1-exp(-1*0.035*fire_history*12));
  }
} else {

  // Gould 2011 hyperbolic model, uses fire_history in years
  if (useTall) {

    // Tall shrub
    fhs_surface = (4.03*fire_history*12)/(27.93+fire_history*12);
    fhs_near_surface = (3.77*fire_history*12)/(48.93+fire_history*12);
    h_near_surface = (28.11*fire_history*12)/(33.84+fire_history*12);

  } else {

    // Low shrub
    fhs_surface = (3.78*fire_history*12)/(20.69+fire_history*12);
    fhs_near_surface = (3.44*fire_history*12)/(50.73+fire_history*12);
    h_near_surface = (22.22*fire_history*12)/(18.55+fire_history*12);
  }
}

</input>
  <input globalname="Output isochrone time">0</input>
  <input globalname="Output shape file">./Output/isochrone.shp</input>
  <input globalname="Output spot fire shape file"></input>
  <input globalname="Output raster file">./Output/arrival.tiff</input>
  <input globalname="Output data raster file">./Output/output.tiff</input>
  <input globalname="Output data raster type">6</input>
  <input globalname="Output stats layers">1</input>
  <input globalname="Output stats script"></input>
  <input globalname="Output stats unit type">0</input>
  <input globalname="Output stats raster file"></input>
  <input globalname="Output stats raster type">6</input>
  <input globalname="Output projection WKT">EPSG:4326</input>
  <input globalname="KML write">0</input>
  <input globalname="KML directory"></input>
  <input globalname="KML time step">0</input>
  <input globalname="Disruption shape source file"></input>
  <input globalname="Disruption shape projection WKT"></input>
  <input globalname="Disruption clear state">1</input>
  <input globalname="Disruption overwrite classification">0</input>
  <input globalname="Disruption overwrite classification value">0</input>
  <input globalname="Disruption overwrite user layer">0</input>
  <input globalname="Disruption overwrite user layer name"></input>
  <input globalname="Disruption overwrite network state name"></input>
  <input globalname="Firebrand active">0</input>
  <input globalname="Firebrand creation"></input>
  <input globalname="Firebrand update"></input>
  <input globalname="Firebrand growth"></input>
  <input globalname="Firebrand airbourne growth"></input>
  <input globalname="Potential active">0</input>
  <input globalname="Potential function parameter">0</input>
  <input globalname="Potential magnitude parameter">0</input>
  <input globalname="Potential elevation parameter">0</input>
  <input globalname="Potential elevation max height">0</input>
  <input globalname="Potential wind conversion">1</input>
  <input globalname="Wind correction active">0</input>
  <input globalname="Wind correction max height">0</input>
  <input globalname="Wind correction vertical layers">0</input>
  <input globalname="Wind correction parameter">0</input>
  <input globalname="RoS 1">// lnc_fc_grassland
// modified geoff.goldrick@protonmail.com 2020-08-18

// CSIRO grasslands models - Cheney et al. (1998)
// Subclasses defined as the following sub type of grasslands:
// 1 - Eaten out
// 2 - Cut / grazed
// 3 - Natural / undisturbed
// 4 - Woodland
// 5 - Open forest

// -------------------------------------------
// Model parameters
// 1. Temperature, 'temp'  (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Curing value, 'curing'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Equations are curve fits adapted from Taylor (1997)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else {
  LBR = 1.1*pow(wind_speed, 0.464);
}

// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters 
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate curing coefficient from Cruz et al. (2015)
REAL curing_coeff;
if ( curing &lt; 20 )
    curing_coeff = 0;
else
    curing_coeff = 1.036 / ( 1 + 103.989 * exp( -0.0996 * (curing - 20) ) );

// Fuel moisture content approximated using McArthur (1966)
REAL GMf = 9.58-(0.205*temp) + (0.138*rel_hum);

// Calculate moisture coefficient from Cheney et al. (1998)
REAL moisture_coeff;
if ( GMf &lt;= 12 ){
    moisture_coeff = exp( -0.108 * GMf );
} else if ( wind_speed &lt;= 10 ){
    moisture_coeff = 0.684 - 0.0342 * GMf; 
} else{
    moisture_coeff = 0.547 - 0.0228 * GMf;} 

// Defining coefficients for the various grasslands sub-types using different subclasses.
REAL head_speed; 
REAL CF_Backing_Slow; 
REAL CF_Backing_Fast; 
REAL CF_Wind_Slow; 
REAL CF_Wind_Fast; 
REAL speed_factor = 1; 

if (subclass == 1) // Eaten out 
    {
    CF_Backing_Slow = 0.027;
    CF_Backing_Fast = 0.55;
    CF_Wind_Slow = 0.1045; 
    CF_Wind_Fast = 0.3575;
    } 
else if (subclass == 2) // Cut or grazed 
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.1;
    CF_Wind_Slow = 0.209;
    CF_Wind_Fast = 0.715; 
    } 
else if (subclass == 3) // Natural or undisturbed
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    } 
else if (subclass == 4) // Woodland  
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.5; 
    } 
else if (subclass == 5) // Open forest
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.3;
    } 

// Calculate spread rate from Cheney et al. (1998) (converting spread rate to m/s from km/hr) 
if ( wind_speed &gt;= 5.0 )
    head_speed = (CF_Backing_Fast + CF_Wind_Fast * pow( (wind_speed - 5), 0.844 ) ) * moisture_coeff * curing_coeff / 3.6;
else
    head_speed = (CF_Backing_Slow + CF_Wind_Slow * wind_speed)* moisture_coeff * curing_coeff / 3.6; 

// Adjust speed based on canopy layer for Northern Australia grassland types (woodland and open forest) 
// Based on Cheney and Sullivan (2008)
head_speed = head_speed * speed_factor;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 2">// lnc_fc_woodlands
// modified geoff.goldrick@protonmail.com 2020-08-18

// CSIRO grasslands models - Cheney et al. (1998)
// Subclasses defined as the following sub type of grasslands:
// 1 - Eaten out
// 2 - Cut / grazed
// 3 - Natural / undisturbed
// 4 - Woodland
// 5 - Open forest

// -------------------------------------------
// Model parameters
// 1. Temperature, 'temp'  (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Curing value, 'curing'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Equations are curve fits adapted from Taylor (1997)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else {
  LBR = 1.1*pow(wind_speed, 0.464);
}

// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters 
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate curing coefficient from Cruz et al. (2015)
REAL curing_coeff;
if ( curing &lt; 20 )
    curing_coeff = 0;
else
    curing_coeff = 1.036 / ( 1 + 103.989 * exp( -0.0996 * (curing - 20) ) );

// Fuel moisture content approximated using McArthur (1966)
REAL GMf = 9.58-(0.205*temp) + (0.138*rel_hum);

// Calculate moisture coefficient from Cheney et al. (1998)
REAL moisture_coeff;
if ( GMf &lt;= 12 ){
    moisture_coeff = exp( -0.108 * GMf );
} else if ( wind_speed &lt;= 10 ){
    moisture_coeff = 0.684 - 0.0342 * GMf; 
} else{
    moisture_coeff = 0.547 - 0.0228 * GMf;} 

// Defining coefficients for the various grasslands sub-types using different subclasses.
REAL head_speed; 
REAL CF_Backing_Slow; 
REAL CF_Backing_Fast; 
REAL CF_Wind_Slow; 
REAL CF_Wind_Fast; 
REAL speed_factor = 1; 

if (subclass == 1) // Eaten out 
    {
    CF_Backing_Slow = 0.027;
    CF_Backing_Fast = 0.55;
    CF_Wind_Slow = 0.1045; 
    CF_Wind_Fast = 0.3575;
    } 
else if (subclass == 2) // Cut or grazed 
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.1;
    CF_Wind_Slow = 0.209;
    CF_Wind_Fast = 0.715; 
    } 
else if (subclass == 3) // Natural or undisturbed
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    } 
else if (subclass == 4) // Woodland  
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.5; 
    } 
else if (subclass == 5) // Open forest
    {
    CF_Backing_Slow = 0.054;
    CF_Backing_Fast = 1.4;
    CF_Wind_Slow = 0.269;
    CF_Wind_Fast = 0.838;
    speed_factor = 0.3;
    } 

// Calculate spread rate from Cheney et al. (1998) (converting spread rate to m/s from km/hr) 
if ( wind_speed &gt;= 5.0 )
    head_speed = (CF_Backing_Fast + CF_Wind_Fast * pow( (wind_speed - 5), 0.844 ) ) * moisture_coeff * curing_coeff / 3.6;
else
    head_speed = (CF_Backing_Slow + CF_Wind_Slow * wind_speed)* moisture_coeff * curing_coeff / 3.6; 

// Adjust speed based on canopy layer for Northern Australia grassland types (woodland and open forest) 
// Based on Cheney and Sullivan (2008)
head_speed = head_speed * speed_factor;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 3">// lnc_fc_sclerophyll_dry
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 4">// lnc_fc_sclerophyll_wet
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Wet Eucalypt model - Adapted from Project VESTA
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// 6. Shrub height, 'fuel_height'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010)
// Initialising the fuel moisture variable
REAL Mf;

// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March)
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);}

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example
else{
    Mf =  3.08 + (0.198*rel_hum) - (0.0483*temp);}  

// Applying wind reduction factors and fuel moisture modifications for wet forest as per Amicus
// These factors depend on the height of the shrubs within the forest
if (fuel_height &lt; 2){
    wind_speed = wind_speed / 2;
    Mf = Mf + 0.2052*Mf + 0.8554;}
else if (fuel_height &gt; 5){
    wind_speed = wind_speed / 3;
    Mf = Mf + 0.5923*Mf + 1.9565;}
else{
    wind_speed = wind_speed / 2.3;
    Mf = Mf + 0.5248*Mf - 0.0568;}

// Calculate moisture coefficients from Burrows (1999)
REAL moisture_coeff = 18.35 * pow(Mf,-1.495);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Using the reduced under canopy wind speed in this case
// Equations are curve fits adapted from Taylor (1997)
REAL LBR;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else if (wind_speed &lt; 25){
  LBR = 0.9286 * exp(0.0505 * wind_speed);
} else {
  LBR = 0.1143 * wind_speed + 0.4143;
}
// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate head fire spread rate (in m/s)
REAL head_speed;
if ( wind_speed &gt; 5 ){
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
} else {
  head_speed = 30.0 * moisture_coeff/3600;}

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 5">// lnc_fc_rainforest
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Wet Eucalypt model - Adapted from Project VESTA
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// 6. Shrub height, 'fuel_height'
// -------------------------------------------

// Calculating the wind speed which is used to calculate head fire ROS
REAL wind_speed = length(wind_vector);

// Calculating the normalised dot product between the wind vector and the normal to the fire perimeter
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010)
// Initialising the fuel moisture variable
REAL Mf;

// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March)
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);}

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example
else{
    Mf =  3.08 + (0.198*rel_hum) - (0.0483*temp);}  

// Applying wind reduction factors and fuel moisture modifications for wet forest as per Amicus
// These factors depend on the height of the shrubs within the forest
if (fuel_height &lt; 2){
    wind_speed = wind_speed / 2;
    Mf = Mf + 0.2052*Mf + 0.8554;}
else if (fuel_height &gt; 5){
    wind_speed = wind_speed / 3;
    Mf = Mf + 0.5923*Mf + 1.9565;}
else{
    wind_speed = wind_speed / 2.3;
    Mf = Mf + 0.5248*Mf - 0.0568;}

// Calculate moisture coefficients from Burrows (1999)
REAL moisture_coeff = 18.35 * pow(Mf,-1.495);

// Calculate length-to-breadth ratio (LBR) which varies with wind speed
// Using the reduced under canopy wind speed in this case
// Equations are curve fits adapted from Taylor (1997)
REAL LBR;
if (wind_speed &lt; 5){
  LBR = 1.0;
} else if (wind_speed &lt; 25){
  LBR = 0.9286 * exp(0.0505 * wind_speed);
} else {
  LBR = 0.1143 * wind_speed + 0.4143;
}
// Determine coefficient for backing and flanking rank of spread using elliptical equations
// Where R_backing = cb * R_head, R_flanking = cf * R_head,
REAL cc = sqrt(1.0-pow(LBR, -2.0));
REAL cb = (1.0-cc)/(1.0+cc);
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR;

// Determine shape parameters
REAL f = 0.5*(1.0+cb);
REAL g = 0.5*(1.0-cb);
REAL h = cf;

// Now calculate a speed coefficient using normal flow formula
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot));

// Calculate head fire spread rate (in m/s)
REAL head_speed;
if ( wind_speed &gt; 5 ){
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
} else {
  head_speed = 30.0 * moisture_coeff/3600;}

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 6">// lnc_fc_other_forest
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 7">// lnc_fc_heath_coastal
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Heathland model - Anderson et al. (2015)
// Model parameters
// These must be defined below, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
// 4. Average fuel height, 'fuel_height' (input)
// 5. Rate of spread for zero wind, 'R0' (input), recommended as 5 m/min.
// 6. Solar radiation factor, 'delta' (input), {0,1}, delta = 1 for sunny days from 12:00 - 17:00 from October to March (high solar radiation) and 0 otherwise.
// -------------------------------------------

//Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
float WF = 0.67;
int R0 = 5;

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) for grassland
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0; 
} else { 
    LBR = 1.1*pow(wind_speed, 0.464); 
} 

// Determine coefficient for flank rank of spread
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0); 
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Initialising the solar radiation variable 
REAL delta; 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    delta = 1;}
else {
    delta = 0;}

// Calculating moisture content 
REAL MC = 4.37 + 0.161*rel_hum - 0.1*(temp - 25) - delta * 0.027 * rel_hum;

REAL head_speed;
// Calculating rate of spread in m/min
if (wind_speed &lt; 5){
    head_speed = (R0 + 0.2*(5.67*pow(5*WF, 0.91) - R0)*wind_speed) * pow(fuel_height, 0.22) * exp(-0.076*MC);
} else {
    head_speed = 5.67 * pow(WF*wind_speed, 0.91) * pow(fuel_height, 0.22) * exp(-0.076*MC); }

// Converting spread rate into m/s
head_speed = head_speed / 60;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 8">// lnc_fc_heath_semi_arid
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Heathland model - Anderson et al. (2015)
// Model parameters
// These must be defined below, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
// 4. Average fuel height, 'fuel_height' (input)
// 5. Rate of spread for zero wind, 'R0' (input), recommended as 5 m/min.
// 6. Solar radiation factor, 'delta' (input), {0,1}, delta = 1 for sunny days from 12:00 - 17:00 from October to March (high solar radiation) and 0 otherwise.
// -------------------------------------------

//Wind reduction factor, 'WF' (input), 0.67 for heath-shrublands and 0.35 for woodlands.
float WF = 0.67;
int R0 = 5;

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR) for grassland
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0; 
} else { 
    LBR = 1.1*pow(wind_speed, 0.464); 
} 

// Determine coefficient for flank rank of spread
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0); 
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Initialising the solar radiation variable 
REAL delta; 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    delta = 1;}
else {
    delta = 0;}

// Calculating moisture content 
REAL MC = 4.37 + 0.161*rel_hum - 0.1*(temp - 25) - delta * 0.027 * rel_hum;

REAL head_speed;
// Calculating rate of spread in m/min
if (wind_speed &lt; 5){
    head_speed = (R0 + 0.2*(5.67*pow(5*WF, 0.91) - R0)*wind_speed) * pow(fuel_height, 0.22) * exp(-0.076*MC);
} else {
    head_speed = 5.67 * pow(WF*wind_speed, 0.91) * pow(fuel_height, 0.22) * exp(-0.076*MC); }

// Converting spread rate into m/s
head_speed = head_speed / 60;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;</input>
  <input globalname="RoS 9">// lnc_fc_pine
// modified geoff.goldrick@protonmail.com 2020-08-18

// -------------------------------------------
// Dry Eucalypt model - Project Vesta
// Model parameters
// These must be defined during init, or included as a user-defined layer
//
// 1. Temperature, 'temp' (input)
// 2. Relative humidity, 'rel_hum' (input)
// 3. Surface fuel hazard score, 'fhs_surface'
// 4. Near-surface fuel hazard score, 'fhs_near_surface'
// 5. Near surface height, 'h_near_surface'
// -------------------------------------------

// Backing and flanking coefficients compared to head fire ROS
REAL wind_speed = length(wind_vector);
REAL wdot = dot(normalize(wind_vector),advect_normal_vector);

// Calculate length-to-breadth ratio (LBR)
REAL LBR = 1.0;
if (wind_speed &lt; 5){
    LBR = 1.0;
} else if (wind_speed &lt; 25){
    LBR = 0.9286 * exp(0.0505 * wind_speed); 
} else {
    LBR = 0.1143 * wind_speed + 0.4143; 
} 

// Determine coefficient for flank rank of spread, Rf = cf * Rh, using Andrew's LBR equations 
REAL cc = sqrt(1.0-pow(LBR, -2.0)); 
REAL cb = (1.0-cc)/(1.0+cc); 
REAL a_LBR = 0.5*(cb+1.0);
REAL cf = a_LBR/LBR; 

// Determine shape parameters 
REAL f = 0.5*(1.0+cb); 
REAL g = 0.5*(1.0-cb); 
REAL h = cf; 

// Now calculate a speed coefficient using normal flow formula 
REAL speed_fraction = (g*wdot+sqrt(h*h+(f*f-h*h)*wdot*wdot)); 

// Estimating fuel moisture content using Gould et al. (2007) and Matthews et al. (2010) 
// Initialising the fuel moisture variable 
REAL Mf; 
// Calculating fuel moisture between 12:00 and 16:59 (valid for sunny days from October to March) 
if (hour &gt; 11 &amp;&amp; hour &lt; 17){
    Mf = 2.76 + (0.124*rel_hum) - (0.0187*temp);}

// Calculating fuel moisture for other daylight hours (from 9:00 to 11:59 and 17:00 to 19:59 in this example)
else if ((hour &lt; 12 &amp;&amp; hour &gt; 8) || (hour &gt; 16 &amp; hour &lt; 20)){
    Mf = 3.6 + (0.169*rel_hum) - (0.045*temp);} 

// Calculating fuel moisture for night time hours (from 20:00 to 8:59) in this example 
else{
    Mf = 3.08 + (0.198*rel_hum) - (0.0483*temp);} 

// Calculate moisture coefficients from Burrows (1999) 
REAL moisture_coeff = 18.35 * pow(Mf,-1.495); 

// Calculate spread rate (in m/s) 
REAL head_speed; 

if ( wind_speed &gt; 5 )
  head_speed = (30.0 + 1.5308 * pow(wind_speed-5,0.8576) * 
           pow(fhs_surface,0.9301) * pow(fhs_near_surface*h_near_surface,0.6366) * 1.03 ) *
           moisture_coeff/3600;
else
  head_speed = 30.0 * moisture_coeff/3600;

// Adjust for calculated speed coefficient for fire flanks
speed = head_speed * speed_fraction;
</input>
  <input globalname="RoS 10">// fc_moorlands

speed = 0.01;</input>
  <input globalname="RoS 11">// fc_wetlands

speed = 0.01;</input>
  <input globalname="RoS 12">// fc_urban = 12;

speed = 0.1;</input>
  <input globalname="Reduction slice">0</input>
  <input globalname="Reduction slice 2">0</input>
  <input globalname="Reduction slice 3">0</input>
  <input globalname="Reduction type">0</input>
  <input globalname="Reduction type 2">0</input>
  <input globalname="Reduction type 3">0</input>
  <input globalname="Reduction script"></input>
  <input globalname="Output header">// Output layers:
//   0: arrival time (s)
//   1: speed (m/s)
//   2: Maximum intensity (kW/m)
//   3: Maximum flame height (m)
//   4: Class
//   5: Vegetation Type
//   6: Unused
//   7: Unused
//   8: Wind vector x-component
//   9: Wind vector y-component

// One-time variables
if (output0 == nodata) {

    output0 = arrival;
    output1 = speed;
    output2 = 0.0;
    output3 = 0.0;
    output4 = class;
    output8 = wind_vector.x;
    output9 = wind_vector.y;
}

// Calculate intensity and flame height
REAL intensity = 18600*speed*fuel_load*0.1;
REAL flame_height = 0.0775*pow(intensity, 0.46);

output2 = max(output2, intensity);
output3 = max(output3, flame_height);</input>
  <input globalname="Output 1"></input>
  <input globalname="Output 2"></input>
  <input globalname="Output 3"></input>
  <input globalname="Output 4"></input>
  <input globalname="Output 5"></input>
  <input globalname="Output 6"></input>
  <input globalname="Output 7"></input>
  <input globalname="Output 8"></input>
  <input globalname="Output 9"></input>
  <input globalname="Output 10"></input>
  <input globalname="Output 11"></input>
  <input globalname="Output 12"></input>
  <input globalname="Project name">LNC_Latest</input>
  <input globalname="PostGIS database name"></input>
  <input globalname="PostGIS host name"></input>
  <input globalname="PostGIS schema name"></input>
  <input globalname="PostGIS table name"></input>
  <input globalname="PostGIS user name"></input>
  <input globalname="PostGIS create script"></input>
  <input globalname="PostGIS append script"></input>
  <input globalname="Vertical levels">1</input>
  <input globalname="Vertical level spacing">0</input>
  <input globalname="Shape file input source"></input>
  <input globalname="GeoJSON input source">{
    &quot;features&quot;: [
        {
            &quot;geometry&quot;: {
                &quot;coordinates&quot;: [
                    152.84230405819085,
                    -30.606294846002235
                ],
                &quot;type&quot;: &quot;Point&quot;
            },
            &quot;properties&quot;: {
                &quot;radius&quot;: 90,
                &quot;time&quot;: &quot;2020-08-22T12:00:00+10:00&quot;
            },
            &quot;type&quot;: &quot;Feature&quot;
        }
    ],
    &quot;type&quot;: &quot;FeatureCollection&quot;
}
</input>
  <input globalname="Simulation number script"></input>
  <input globalname="Simulation duration hours">24</input>
  <input globalname="Simulation projection WKT">EPSG:28356</input>
  <input globalname="Simulation resolution">30</input>
  <input globalname="Start point script">long = [152.845]
lat = [-30.5933]
radius = [120]
# time = [3600]
time = [&quot;2020-08-22T13:00:00+10:00&quot;]</input>
  <input globalname="Start condition projection WKT">EPSG:4326</input>
  <input globalname="Start time">2020-08-22T06:00:00+10:00</input>
  <input globalname="End time"></input>
  <input globalname="Number of simulations">0</input>
  <input globalname="Random seed">0</input>
  <input globalname="Verbose">0</input>
  <input globalname="Gridded/Relative humidity/Layer scheme">0</input>
  <input globalname="Gridded/Relative humidity/Layer opacity">1</input>
  <input globalname="Gridded/Temperature/Layer scheme">0</input>
  <input globalname="Gridded/Temperature/Layer opacity">1</input>
  <input globalname="Gridded/Dew point temperature/Layer scheme">0</input>
  <input globalname="Gridded/Dew point temperature/Layer opacity">1</input>
  <input globalname="Gridded/Drought factor/Layer scheme">0</input>
  <input globalname="Gridded/Drought factor/Layer opacity">1</input>
  <input globalname="Map operational shape source file"></input>
  <input globalname="Map asset shape source file"></input>
  <input globalname="Map shape projection WKT"></input>
  <input globalname="Slippy map URL">https://tile.openstreetmap.org/</input>
  <input globalname="Slippy map transpose">0</input>
  <input globalname="Slippy map text">OpenStreetMap contributors</input>
  <input globalname="Slippy map proxy"></input>
  <input globalname="Slippy map port">0</input>
  <input globalname="Slippy map reproject">0</input>
  <input globalname="View isochrone colour" rgba="4282400832"/>
  <input globalname="View isochrone fill type">1</input>
  <input globalname="Comparison output raster file"></input>
</operation>
